主要针对java堆和方法区进行垃圾回收    java栈 本地方法区  程序计数器随线程生灭
垃圾回收 garbage collection GC
一 判断对象已死
1 引用计数法 给每个对象添加一个引用计数器 有引用计数加1 引用失效减1 计数为0对象不能再使用 难以解决对象间仙湖引用，相互引用导致计数都不为0 java不使用
2 根搜索算法 通过一系列名为"GC Roots" 的对象作为起始点，从这些节点向下搜索，经过路径称为引用链 ，当一个对象到GC Roots之间无引用链 则对象不可用
对象间用关联 但没有到根的引用链 将判定可回收
GC Roots的对象 虚拟机栈中的引用对象 方法区中类静态属性 常量引用对象本地方法栈中JNI引用对像
引用分类 强引用 软 弱 
强引用 只用引用存在，垃圾回收器永远不会收掉被引用对像
软引用 还有用，并非必须 在发生内存溢出之前，会将所引对象列入回收范围并进行二次回收
弱引用  非必须，强度更弱 只能生存到下一次垃圾回收之前垃圾收集器工作时，无论内存是否足够，都会回收
虚引用 不会影响其生存时间 无法通过虚引用取得一个对象实例 使用目的是在回收时收到系统通知
在根搜索中不可达对象，并非直接死，经历两次标记判死。搜索发现无引用链，一次标记并进行一次筛选，筛选条件是有必要进行执行finalize方法，
若覆盖过finalize方法或被吊用过，则没必要。有必要执行finalize方法，对像放置到F-Queue队列中等待执行，GC会在F-Queue，进行二次标记，
此时若与引用链上建立关联就会将自己拯救，任何对象finalize方法会被系统自动调用一次，只有一次，下次回收方法不再执行
finalize方法不确定性大开销大不推荐，不如使用try-finally
方法区回收 废弃常量 无用的类
无用的类判定 1所有实例已被回收2类的ClassLoader已经被回收3类的java.lang.Class对象无引用，无法通过反射获得该类的方法。
二 垃圾收集算法

1 标记-清除算法 先标记出要回收的对像，统一回收。效率不高 空间利用率低 产生不连续碎片。

2 复制算法 将内存划分成两块，每次使用一块，一块用完将活着的复制到另一块，清除另一块。
商业虚拟机使用回收新生代 内存划分8:1:1 每次使用90% 将活着的复制到10%，需要依赖其他内存(老年代)担保分配。

3 标记-整理算法 针对老年代(存活时间较长),不是直接回收，让所有存活对象都向一端移动，然后清除边界外的内存

4 分代收集算法 根据对象存活周期划分内存，新生代，老年代。新生代复制算法。老年代标记清理，标记整理。
三 垃圾收集器 
并行 垃圾收集并行工作 用户线程等。并发 用户垃圾收集同时执行。
1 serial收集器 新生代 单线程 简单高效 工作时用户线程全部停掉

2 parnew收集器 新生代 多线程 多运行在server下 可配合CMS CPU越多效果越好

3 parallel scavenge 新生代  复制算法 多线程 注重吞吐量(运行用户代码占比大)
停顿时间短 用户交互多。 吞吐量大 后台运算

4 serial old 老年代 单线程 标记整理 client模式下。server下配合 parallel scavenge ，作为CMS备案。

5 paralle lold 老年代 多线程 标记整理 鸡肋
6 CMS 以获取最短回收停顿时间为目标的收集器，注重响应速度。标记清除算法， 并发收集 低停顿

执行分为4 步 初始标记，并发标记，重新标记，并发清除。
初始标记 停用户线程 仅标记有引用链对象
并发标记 并发用户线程 GC Roots Trancing 
重新标记 停用户线程 修正并发标记
并发清除 并发用户线程 
缺点 cpu资源敏感 无法处理浮动垃圾 空间碎片
7 G1 收集器 标记整理算法 无空间碎片 精确控制停顿

四 内存分配回收策略
新生代GC Minor GC 频繁 回收速度快。老年代GC Full GC/Magor GC 伴随至少一次minor GC 慢
对象优先在Eden分配
大对象直接进老年代
长期存活对象进老年代 设置年龄 一次存活进入survivor  年龄到进去老年代
动态对象年龄判定 survivor中相同年龄对象空间总和大于survivor空间一半 年龄大于该对象的进入老年代
空间分配担保 老年代剩余小于平均存活 复制到老年代要不要先full GC 有担保 减少full次数。
